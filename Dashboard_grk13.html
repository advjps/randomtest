<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Crypto Leverage Trade Dashboard</title>
  <style>
    body { font-family: Arial, sans-serif; background: #f4f4f4; color: #333; margin: 0; padding: 10px; }
    h1, h2 { text-align: center; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; font-size: 13px; }
    th, td { padding: 8px 5px; text-align: center; border-bottom: 1px solid #ddd; }
    th { background: #007bff; color: white; }
    td.bold { font-weight: bold; font-size: 15px; }
    .progress-container { width: 100%; background: #ddd; border-radius: 5px; margin: 10px 0; }
    .progress-bar { width: 0%; height: 12px; background: #007bff; border-radius: 5px; }
    .spinner { display: none; margin-left: 10px; border: 3px solid #f3f3f3; border-top: 3px solid #007bff; border-radius: 50%; width: 16px; height: 16px; animation: spin 1s linear infinite; }
    @keyframes spin { 100% { transform: rotate(360deg); } }
    .buy { background-color: #d8f8d8; }
    .sell { background-color: #f8d8d8; }
    .top-pick { background-color: #b5e7b5 !important; }
    .top-pick-sell { background-color: #e7b5b5 !important; }
    .pop-high { color: green; font-weight: bold; }
    .pop-medium { color: orange; font-weight: bold; }
    .pop-low { color: red; font-weight: bold; }
    .raw-section { margin-top: 20px; background: #fff; padding: 10px; border-radius: 8px; }
    #raw-data { width: 100%; height: 150px; font-size: 12px; font-family: monospace; display: none; }
    button { margin: 5px; }
    @media (max-width: 768px) { table { font-size: 11px; } td.bold { font-size: 13px; } }
  </style>
</head>
<body>
  <h1>Crypto Leverage Trade Dashboard</h1>
  <p style="text-align:center;">Last Updated: <span id="last-update">--:--</span></p>
  <p style="text-align:center;">Next Refresh Suggested In: <span id="countdown">--:--</span></p>
  <div style="text-align:center;">
    <button id="refresh-btn">Refresh Data</button>
    <div class="spinner" id="spinner"></div>
  </div>
  <div class="progress-container"><div class="progress-bar" id="progress-bar"></div></div>

  <div class="section" id="strong-buy-section">
    <h2>Strong Buy</h2>
    <table>
      <thead>
        <tr><th>Coin</th><th>Price</th><th>TP</th><th>SL</th><th>Leverage</th><th>POP</th><th>RSI</th><th>Estimated Profit</th></tr>
      </thead>
      <tbody id="strong-buy-body"></tbody>
    </table>
    <p id="strong-buy-filter"></p>
  </div>

  <div class="section" id="strong-sell-section">
    <h2>Strong Sell</h2>
    <table>
      <thead>
        <tr><th>Coin</th><th>Price</th><th>TP</th><th>SL</th><th>Leverage</th><th>POP</th><th>RSI</th><th>Estimated Profit</th></tr>
      </thead>
      <tbody id="strong-sell-body"></tbody>
    </table>
    <p id="strong-sell-filter"></p>
  </div>

  <div class="raw-section">
    <button id="toggle-raw-btn">Show Raw Data</button>
    <button id="copy-btn">Copy Raw Data</button>
    <button id="download-btn">Download JSON</button>
    <textarea id="raw-data" readonly></textarea>
  </div>
<script>
  const coins = [
    'BTCUSDT','ETHUSDT','DOGEUSDT','SOLUSDT','XRPUSDT','GALAUSDT','CFXUSDT','PEPEUSDT','ENAUSDT','PNUTUSDT',
    'REZUSDT','SHIBUSDT','ETCUSDT','HBARUSDT','CKBUSDT','ARBUSDT','WLDUSDT','UNIUSDT','AVAXUSDT','XLMUSDT',
    'WIFUSDT','AAVEUSDT'
  ];
  let countdownInterval;

  document.getElementById('refresh-btn').addEventListener('click', fetchData);
  document.getElementById('toggle-raw-btn').addEventListener('click', () => {
    const rawBox = document.getElementById('raw-data');
    rawBox.style.display = rawBox.style.display === 'none' ? 'block' : 'none';
  });
  document.getElementById('copy-btn').addEventListener('click', () => {
    document.getElementById('raw-data').select();
    document.execCommand('copy');
    alert('Raw data copied!');
  });
  document.getElementById('download-btn').addEventListener('click', () => {
    const blob = new Blob([document.getElementById('raw-data').value], { type: 'application/json' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const nowIST = new Date(new Date().getTime() + (5.5 * 60 * 60 * 1000));
    const tsIST = nowIST.toISOString().replace(/[:.]/g,'-').replace('T', '_').split('.')[0];
    link.download = `crypto_signals_${tsIST}_IST.json`;
    link.click();
  });

  async function fetchTopVolumeCoins() {
    const exchangeInfoUrl = 'https://fapi.binance.com/fapi/v1/exchangeInfo';
    const futuresTickersUrl = 'https://fapi.binance.com/fapi/v1/ticker/24hr';
    
    try {
        // Step 1: Get a list of all active symbols from exchange info
        const exchangeInfoResponse = await fetch(exchangeInfoUrl);
        if (!exchangeInfoResponse.ok) {
            throw new Error(`HTTP error! status: ${exchangeInfoResponse.status}`);
        }
        const exchangeInfoData = await exchangeInfoResponse.json();
        const activeSymbols = new Set(exchangeInfoData.symbols
            .filter(s => s.status === 'TRADING' && s.contractType === 'PERPETUAL')
            .map(s => s.symbol));

        // Step 2: Get all tickers and filter for active ones
        const response = await fetch(futuresTickersUrl);
        if (!response.ok) {
            throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        
        const tradableUsdtPairs = data.filter(ticker => 
            ticker.symbol.endsWith('USDT') && activeSymbols.has(ticker.symbol)
        );

        // Sort by quote volume and return the top 70 symbols
        const sortedCoins = tradableUsdtPairs
            .sort((a, b) => b.quoteVolume - a.quoteVolume)
            .slice(0, 70)
            .map(ticker => ticker.symbol);

        return sortedCoins;
    } catch (e) {
        console.error("Error fetching top coins:", e);
        // Return a default list in case of failure
        return [
            'BTCUSDT','ETHUSDT','DOGEUSDT','SOLUSDT','XRPUSDT','GALAUSDT','CFXUSDT','PEPEUSDT','ENAUSDT','PNUTUSDT',
            'REZUSDT','SHIBUSDT','ETCUSDT','HBARUSDT','CKBUSDT','ARBUSDT','WLDUSDT','UNIUSDT','AVAXUSDT','XLMUSDT',
            'WIFUSDT','AAVEUSDT'
        ];
    }
}

  async function fetchData() {
    clearInterval(countdownInterval);
    startSpinner(true);
    updateProgress(0);

    // Get the dynamic list of top coins
    const dynamicCoins = await fetchTopVolumeCoins();
    // Use this dynamic list for the rest of the function
    const coinsToAnalyze = dynamicCoins.length > 0 ? dynamicCoins : coins;

    // Fetch Bitcoin data separately first
    const btcData5m = await fetchBinanceDataWithFallback('BTCUSDT', '5m');
    const btcCloses5m = btcData5m.map(d => d.close);
    const marketTrend = calcMarketTrend(btcCloses5m);

    // Create an array of promises for fetching all coins
    const coinPromises = coinsToAnalyze.map(symbol =>
        Promise.all([
            fetchBinanceDataWithFallback(symbol, '5m'),
            fetchBinanceDataWithFallback(symbol, '1m')
        ])
        .then(([data5m, data1m]) => {
            // Pass the market trend score to analyzeData
            const analysis = analyzeData(symbol, data5m, data1m, marketTrend); 
            return analysis;
        })
        .catch(e => {
            console.error(`Error fetching ${symbol}:`, e);
            return {
                coin: symbol,
                price: 0, tp: "0.0000", sl: "0.0000", leverage: "5x", pop: 0, rsi: 0,
                estimated_profit: "0.00%", signal: "Neutral", indicators: {}
            };
        })
    );
    
    // Use Promise.allSettled to wait for all promises to either succeed or fail
    const results = await Promise.allSettled(coinPromises);
    
    // Filter out rejected promises and get the successful results
    const successfulResults = results
        .filter(result => result.status === 'fulfilled')
        .map(result => result.value);

    // Filter results to show only Strong Buy/Sell with at least 4% Estimated Profit
    const filteredResults = successfulResults.filter(r => 
        (r.signal === "Strong Buy" || r.signal === "Strong Sell") &&
        parseFloat(r.estimated_profit) >= 4
    );

    updateDashboard(filteredResults, successfulResults);
    updateRawData(successfulResults);
    document.getElementById('last-update').textContent = new Date().toLocaleTimeString();
    startSpinner(false);
    startCountdown(300);
}

  async function fetchBinanceDataWithFallback(symbol, timeframe) {
  // Changed limit to 200 for more data for indicators
  const url = `https://api.binance.com/api/v3/klines?symbol=${symbol}&interval=${timeframe}&limit=100`; // Updated
  try { return await fetchBinanceData(url); }
  catch (err) {
    const proxyUrl = `https://cors-anywhere.herokuapp.com/${url}`;
    return await fetchBinanceData(proxyUrl);
  }
}
  async function fetchBinanceData(url) {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`HTTP ${response.status}`);
    const data = await response.json();
    return data.map(d => ({ open: +d[1], high: +d[2], low: +d[3], close: +d[4], volume: +d[5] }));
  }

   function analyzeData(symbol, data5m, data1m, marketTrend) {
    // --- Data Extraction & Indicator Calculation ---
    const currentPrice = data5m[data5m.length - 1]?.close;
    if (!currentPrice || data5m.length < 50) {
      return { coin: symbol, signal: "Neutral" }; // Exit early if insufficient data
    }

    const closes = data5m.map(d => d.close).filter(v => Number.isFinite(v));
    const highs = data5m.map(d => d.high).filter(v => Number.isFinite(v));
    const lows = data5m.map(d => d.low).filter(v => Number.isFinite(v));
    const volumes = data5m.map(d => d.volume).filter(v => Number.isFinite(v));

    // Calculate only the indicators needed for the new strategy
    const rsiArray = calcRSI(closes, 14);
    const macdObj = calcMACD(closes, 12, 26, 9);
    const boll = calcBollinger(closes, 20, 2);
    const atr = calcATR(highs, lows, closes, 14);
    const cci = calcCCI(highs, lows, closes, 20);
    const volProfileScores = calcVolumeProfile(closes, highs, lows, volumes);
    const ema50_array = calcEMA(closes, 50);
    const adx = calcADX(highs, lows, closes, 14);

    const latestRSI = getLastValidValue(rsiArray);
    const latestBBUpper = boll.upper;
    const latestBBLower = boll.lower;
    const latestCCI = cci;
    const latestMACDHist = macdObj.latest.histogram;
    const latestVolProfileBull = volProfileScores.bullish_score;
    const latestVolProfileBear = volProfileScores.bearish_score;
    const latestEMA50 = getLastValidValue(ema50_array);
    const latestADX = adx;
    
    // ==================================================================
    // ### SCORING SYSTEM V2.2 ('The 2nd Amendment') ###
    // ==================================================================

    let buyScore = 0;
    let sellScore = 0;
    let vetoApplied = false;

    // --- 1. CORE MEAN-REVERSION SCORING ---
    if (currentPrice <= latestBBLower) { buyScore += 35; }
    if (latestRSI <= 30) { buyScore += 30; } 
    else if (latestRSI > 30 && latestRSI <= 40) { buyScore += 15; }
    if (latestCCI >= 100) { buyScore += 25; }

    if (currentPrice >= latestBBUpper) { sellScore += 35; }
    if (latestRSI >= 70) { sellScore += 30; } 
    else if (latestRSI < 70 && latestRSI >= 60) { sellScore += 15; }
    if (latestCCI <= -100) { sellScore += 25; }

    // --- 2. NEGLIGIBLE SCORES (for data tracking) ---
    if (latestADX > 25) { buyScore += 1; sellScore += 1; }
    if (currentPrice > latestEMA50) { buyScore += 1; }
    if (currentPrice < latestEMA50) { sellScore += 1; }

    // --- 3. ADVANCED VETO FILTERS ---
    if (marketTrend <= -10) { // Strongly Bearish Market
      buyScore = -999; vetoApplied = true;
    } else if (marketTrend >= 10) { // Strongly Bullish Market
      sellScore = -999; vetoApplied = true;
    } else if (marketTrend <= -5) { // Moderately Bearish
      sellScore += 15; buyScore -= 10;
    } else if (marketTrend >= 5) { // Moderately Bullish
      buyScore += 15; sellScore -= 10;
    }

    const volProfileScore = (buyScore > sellScore) ? latestVolProfileBull : latestVolProfileBear;
    if (volProfileScore === 0) {
      buyScore -= 50; sellScore -= 50; vetoApplied = true;
    }

    if (latestMACDHist > 0 && sellScore > buyScore) {
      sellScore -= 45; vetoApplied = true;
    }

   // --- 4. FINAL SIGNAL DETERMINATION (V2.3 Complete) ---
    let signalType = "Neutral";
    let pop = 0;
    const STRONG_THRESHOLD = 25;

    // First, determine the direction based on which score is higher
    if (buyScore > sellScore) { // Bullish case
        if (buyScore >= STRONG_THRESHOLD) {
            signalType = "Strong Buy";
        } else if (buyScore > 0) { // A buy signal is only possible if the buyScore is positive
            signalType = "Buy";
        }
    } else if (sellScore > buyScore) { // Bearish case
        if (sellScore >= STRONG_THRESHOLD) {
            signalType = "Strong Sell";
        } else if (sellScore > 0) { // A sell signal is only possible if the sellScore is positive
            signalType = "Sell";
        }
    }

    // Downgrade penalized signals from "Strong" status
    if (vetoApplied && (signalType.includes("Strong"))) {
        signalType = (signalType === "Strong Buy") ? "Buy" : "Sell";
    }

    // Calculate POP score based on the final scores
    if (signalType.includes("Buy")) {
        pop = Math.min(100, Math.round((buyScore / (buyScore + sellScore || 1)) * 100));
    } else if (signalType.includes("Sell")) {
        pop = Math.min(100, Math.round((sellScore / (buyScore + sellScore || 1)) * 100));
    } else {
        pop = 50;
    }
    pop = pop < 0 ? 0 : pop; // Ensure pop is never negative

    // TP/SL and Leverage must be calculated before the final profit filter
    let leverage = 5;
    if (pop >= 80) leverage = 9;
    else if (pop >= 65) leverage = 7;
    else if (pop >= 50) leverage = 6;
    
    const effectiveATR = (Number.isFinite(atr) && atr > 0) ? atr : currentPrice * 0.002;
    let tp, sl;
    if (signalType.includes("Buy")) {
      tp = currentPrice + (effectiveATR * 1.5);
      sl = currentPrice - (effectiveATR * 1.5); // Using new slFactor
    } else if (signalType.includes("Sell")) {
      tp = currentPrice - (effectiveATR * 1.5);
      sl = currentPrice + (effectiveATR * 1.5); // Using new slFactor
    } else {
      tp = currentPrice; sl = currentPrice;
    }
    const profitPct = Math.abs(((tp - currentPrice) / currentPrice) * 100 * leverage);
     
    // --- 5. FINAL VETO FILTER BASED ON PROFIT % ---
    if (profitPct > 7.0 && signalType.includes("Strong")) {
      signalType = "Neutral"; // Veto the signal if estimated profit is too high
    }

    // Final POP calculation
    if (signalType.includes("Buy")) {
      pop = Math.min(100, Math.round((buyScore / (buyScore + Math.abs(sellScore) || 1)) * 100));
    } else if (signalType.includes("Sell")) {
      pop = Math.min(100, Math.round((sellScore / (Math.abs(buyScore) + sellScore || 1)) * 100));
    } else {
      pop = 50;
    }
    
    return {
      coin: symbol,
      price: currentPrice,
      tp: tp.toFixed(4),
      sl: sl.toFixed(4),
      leverage: leverage + "x",
      pop: pop < 0 ? 0 : pop,
      rsi: latestRSI,
      estimated_profit: profitPct.toFixed(2) + "%",
      signal: signalType,
      volProfile: volProfileScores,
      indicators: {
        rsi5m: latestRSI, macd5m: macdObj.latest, boll5m: boll,
        cci5m: latestCCI, marketTrend: marketTrend, volProfile: volProfileScores,
        ema50_5m: latestEMA50, adx5m: latestADX,
      }
    };
  }
  
  // --- Replacement Indicator Functions ---

// Helper function to get the last valid value from an array
function getLastValidValue(arr) {
    for (let i = arr.length - 1; i >= 0; i--) {
        if (Number.isFinite(arr[i])) {
            return arr[i];
        }
    }
    return NaN; // Or 0, depending on desired default
}

// Helper function to get the last valid value from an array (KEEP THIS AS IS)
// function getLastValidValue(arr) { ... }

// 1. EMA (Exponential Moving Average) - Returns an array of EMA values
function calcEMA(values, period) {
    const emaArray = Array(values.length).fill(NaN); // Pre-fill with NaN

    if (!values || values.length < period) {
        return emaArray; // Return all NaNs if insufficient data
    }

    const k = 2 / (period + 1);
    let ema = NaN; // Current EMA value, initialized to NaN

    // --- Phase 1: Find the first starting point for EMA calculation ---
    // We need to find the first index 'i' where values[i] to values[i + period - 1]
    // are all valid, finite numbers.
    let firstValidSMAIndex = -1;
    for (let i = 0; i <= values.length - period; i++) {
        const slice = values.slice(i, i + period);
        if (slice.every(val => Number.isFinite(val) && val > 0)) {
            firstValidSMAIndex = i;
            break;
        }
    }

    if (firstValidSMAIndex === -1) {
        // console.warn(`calcEMA: Period ${period} - No full, clean period of data found. Returning all NaNs.`);
        return emaArray; 
    }

    // --- Phase 2: Calculate the initial EMA from the first valid period ---
    let initialSum = values.slice(firstValidSMAIndex, firstValidSMAIndex + period).reduce((a, b) => a + b);
    ema = initialSum / period;

    // Place the first valid EMA value at the correct index
    emaArray[firstValidSMAIndex + period - 1] = ema;

    // --- Phase 3: Continue EMA calculation from that point ---
    for (let i = firstValidSMAIndex + period; i < values.length; i++) {
        const val = values[i];
        
        // Propagate NaN if current value is invalid OR previous EMA was NaN
        if (!Number.isFinite(val) || val <= 0 || isNaN(ema)) { 
            emaArray[i] = NaN;
            ema = NaN; // Ensure ema is NaN for next iteration as well
            continue; 
        }

        ema = (val * k) + (ema * (1 - k));
        emaArray[i] = ema;
    }
    return emaArray;
}
  // 2. RSI (Relative Strength Index) - Returns an array of RSI values
function calcRSI(values, period = 14) {
    const rsiArray = [];
    if (!values || values.length < period + 1) {
        return Array(values.length).fill(NaN); // Fill array with NaN if insufficient data
    }

    let avgGain = 0;
    let avgLoss = 0;

    // Calculate initial average gain/loss for the first period
    let initialGains = 0;
    let initialLosses = 0;
    for (let i = 1; i <= period; i++) {
        const change = values[i] - values[i-1];
        if (Number.isFinite(change)) { // Only consider finite changes
            if (change > 0) {
                initialGains += change;
            } else {
                initialLosses += Math.abs(change);
            }
        }
    }
    avgGain = initialGains / period;
    avgLoss = initialLosses / period;

    // Fill initial periods with NaN
    for (let i = 0; i < period; i++) {
        rsiArray.push(NaN); 
    }

    // First RSI calculation
    let rs = (avgLoss === 0) ? Infinity : avgGain / avgLoss;
    let rsi = 100 - (100 / (1 + rs));
    rsiArray.push(Number.isFinite(rsi) ? rsi : NaN); // Push first valid RSI or NaN


    for (let i = period + 1; i < values.length; i++) {
        const change = values[i] - values[i-1];
        let gain = 0;
        let loss = 0;

        if (!Number.isFinite(change)) { // If change is not finite, propagate NaN
            avgGain = NaN;
            avgLoss = NaN;
        } else {
            if (change > 0) {
                gain = change;
            } else {
                loss = Math.abs(change);
            }
            avgGain = ((avgGain * (period - 1)) + gain) / period;
            avgLoss = ((avgLoss * (period - 1)) + loss) / period;
        }
        
        rs = (Number.isFinite(avgGain) && Number.isFinite(avgLoss) && avgLoss === 0) ? Infinity : (Number.isFinite(avgGain) && Number.isFinite(avgLoss) ? avgGain / avgLoss : NaN);
        rsi = 100 - (100 / (1 + rs));
        rsiArray.push(Number.isFinite(rsi) ? rsi : NaN);
    }
    return rsiArray;
}
// A simple SMA function to be used internally by calcMACD and calcStochastic
function calcSMA(values, period) {
    const smaArray = Array(values.length).fill(NaN);
    if (!values || values.length < period) {
        return smaArray;
    }

    let sum = 0;
    for (let i = 0; i < period - 1; i++) {
        sum += Number.isFinite(values[i]) ? values[i] : 0;
    }

    for (let i = period - 1; i < values.length; i++) {
        sum += Number.isFinite(values[i]) ? values[i] : 0;
        smaArray[i] = sum / period;
        sum -= Number.isFinite(values[i - (period - 1)]) ? values[i - (period - 1)] : 0;
    }
    return smaArray;
}

// 3. MACD (Moving Average Convergence Divergence) - Returns object with arrays
function calcMACD(values, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
    const macdResult = {
        macdLine: Array(values.length).fill(NaN),
        signalLine: Array(values.length).fill(NaN),
        histogram: Array(values.length).fill(NaN),
        latest: { macd: NaN, signal: NaN, histogram: NaN }
    };

    if (!values || values.length < slowPeriod) {
        return macdResult;
    }

    const fastEMA_values = calcEMA(values, fastPeriod);
    const slowEMA_values = calcEMA(values, slowPeriod);
    
    // Calculate MACD Line
    for (let i = 0; i < values.length; i++) {
        if (Number.isFinite(fastEMA_values[i]) && Number.isFinite(slowEMA_values[i])) {
            macdResult.macdLine[i] = fastEMA_values[i] - slowEMA_values[i];
        } else {
            macdResult.macdLine[i] = NaN;
        }
    }

    // Calculate Signal Line (using SMA of the MACD Line for robustness)
    const signalLineValues = calcSMA(macdResult.macdLine, signalPeriod);
    
    // Copy valid signal line values to macdResult.signalLine
    for(let i = 0; i < values.length; i++) {
        if (Number.isFinite(signalLineValues[i])) {
            macdResult.signalLine[i] = signalLineValues[i];
        } else {
            macdResult.signalLine[i] = NaN;
        }
    }
    
    // Calculate MACD Histogram
    for (let i = 0; i < values.length; i++) {
        if (Number.isFinite(macdResult.macdLine[i]) && Number.isFinite(macdResult.signalLine[i])) {
            macdResult.histogram[i] = macdResult.macdLine[i] - macdResult.signalLine[i];
        } else {
            macdResult.histogram[i] = NaN;
        }
    }
    
    macdResult.latest.macd = getLastValidValue(macdResult.macdLine);
    macdResult.latest.signal = getLastValidValue(macdResult.signalLine);
    macdResult.latest.histogram = getLastValidValue(macdResult.histogram);

    return macdResult;
}  
  
  // 4. Stochastic Oscillator - Returns object with arrays for %K and %D
function calcStochastic(highs, lows, closes, kPeriod = 14, dPeriod = 3) {
    const stochasticResult = {
        kLine: Array(closes.length).fill(NaN), 
        dLine: Array(closes.length).fill(NaN), 
        latest: { k: NaN, d: NaN }
    };
    if (!highs || !lows || !closes || highs.length < kPeriod || lows.length < kPeriod || closes.length < kPeriod) {
        return stochasticResult;
    }
    
    // Calculate K line
    for (let i = kPeriod - 1; i < closes.length; i++) {
        const sliceHigh = highs.slice(i - kPeriod + 1, i + 1).filter(v => Number.isFinite(v)); 
        const sliceLow = lows.slice(i - kPeriod + 1, i + 1).filter(v => Number.isFinite(v));   
        const currentClose = closes[i];

        if (sliceHigh.length === 0 || sliceLow.length === 0 || !Number.isFinite(currentClose)) {
            stochasticResult.kLine[i] = NaN;
            continue;
        }

        const highest = Math.max(...sliceHigh); 
        const lowest = Math.min(...sliceLow);   

        let k = NaN;
        if (Number.isFinite(currentClose) && Number.isFinite(highest) && Number.isFinite(lowest) && (highest - lowest !== 0)) { 
            k = ((currentClose - lowest) / (highest - lowest)) * 100;
        }
        stochasticResult.kLine[i] = Number.isFinite(k) ? k : NaN;
    }
    
    // Calculate D line (using SMA of K line for robustness)
    const dValues = calcSMA(stochasticResult.kLine, dPeriod); 
    
    // Copy valid dLine values to result
    for(let i = 0; i < closes.length; i++) {
        if (Number.isFinite(dValues[i])) {
            stochasticResult.dLine[i] = dValues[i];
        } else {
            stochasticResult.dLine[i] = NaN;
        }
    }
    
    stochasticResult.latest.k = getLastValidValue(stochasticResult.kLine);
    stochasticResult.latest.d = getLastValidValue(stochasticResult.dLine);

    return stochasticResult;
}
  
// 5. OBV (On-Balance Volume) - Returns an array of OBV values
function calcOBV(closes, volumes) {
    const obvArray = [];
    if (!closes || !volumes || closes.length === 0 || volumes.length === 0 || closes.length !== volumes.length) {
        // If invalid input, return array of NaNs matching closes length if possible, else empty
        return Array(closes ? closes.length : 0).fill(NaN); 
    }

    let obv = 0;
    if (closes.length > 0 && Number.isFinite(volumes[0])) {
        obv = volumes[0]; // Initialize OBV with the volume of the first bar
        obvArray.push(obv);
    } else {
        obvArray.push(NaN); // Push NaN if initial value is invalid
        obv = NaN; // Propagate NaN
    }

    for (let i = 1; i < closes.length; i++) {
        const currentClose = closes[i];
        const prevClose = closes[i-1];
        const currentVolume = volumes[i];

        if (!Number.isFinite(currentClose) || !Number.isFinite(prevClose) || !Number.isFinite(currentVolume) || isNaN(obv)) {
            obvArray.push(NaN);
            obv = NaN; // Propagate NaN
            continue;
        }

        if (currentClose > prevClose) {
            obv += currentVolume;
        } else if (currentClose < prevClose) {
            obv -= currentVolume;
        }
        // If close[i] == close[i-1], OBV remains unchanged for that bar
        obvArray.push(obv);
    }
    return obvArray;
}
// --- Helper Functions for Divergence Detection (Optional but powerful) ---
// These are more advanced and might require careful tuning for different timeframes.
// For initial implementation, we might not use these directly in the scoring,
// but having the arrays enables you to develop this later.

// Simplistic swing high/low detection for an array
function getSwingHighsLows(values, pivotStrength = 3) {
    const highs = [];
    const lows = [];
    for (let i = pivotStrength; i < values.length - pivotStrength; i++) {
        let isSwingHigh = true;
        let isSwingLow = true;
        for (let j = 1; j <= pivotStrength; j++) {
            if (values[i] <= values[i - j] || values[i] <= values[i + j]) {
                isSwingHigh = false;
            }
            if (values[i] >= values[i - j] || values[i] >= values[i + j]) {
                isSwingLow = false;
            }
        }
        if (isSwingHigh) highs.push({ index: i, value: values[i] });
        if (isSwingLow) lows.push({ index: i, value: values[i] });
    }
    return { highs, lows };
}

// Basic divergence check
function checkForDivergence(priceHighs, priceLows, indicatorValues, indicatorHighs, indicatorLows, type) {
    // type: 'bullish' or 'bearish'
    // Simplified: Look for a recent (e.g., last 3-5) price swing point and corresponding indicator swing point.
    // This function would need to be very robust to be reliable.
    // For now, it's illustrative.

    if (type === 'bullish') {
        // Price makes a lower low, Indicator makes a higher low
        for (let i = priceLows.length - 1; i >= 1; i--) {
            const currentPriceLow = priceLows[i];
            const prevPriceLow = priceLows[i-1];
            if (currentPriceLow.value < prevPriceLow.value) { // Price lower low
                // Find corresponding indicator lows
                const currentIndLow = indicatorLows.find(l => l.index >= currentPriceLow.index - 5 && l.index <= currentPriceLow.index + 5);
                const prevIndLow = indicatorLows.find(l => l.index >= prevPriceLow.index - 5 && l.index <= prevPriceLow.index + 5);

                if (currentIndLow && prevIndLow && currentIndLow.value > prevIndLow.value) {
                    return true; // Bullish Divergence found
                }
            }
        }
    } else if (type === 'bearish') {
        // Price makes a higher high, Indicator makes a lower high
        for (let i = priceHighs.length - 1; i >= 1; i--) {
            const currentPriceHigh = priceHighs[i];
            const prevPriceHigh = priceHighs[i-1];
            if (currentPriceHigh.value > prevPriceHigh.value) { // Price higher high
                // Find corresponding indicator highs
                const currentIndHigh = indicatorHighs.find(h => h.index >= currentPriceHigh.index - 5 && h.index <= currentPriceHigh.index + 5);
                const prevIndHigh = indicatorHighs.find(h => h.index >= prevPriceHigh.index - 5 && h.index <= prevPriceHigh.index + 5);

                if (currentIndHigh && prevIndHigh && currentIndHigh.value < prevIndHigh.value) {
                    return true; // Bearish Divergence found
                }
            }
        }
    }
    return false;
}

// --- End of Replacement Indicator Functions ---

  function calcBollinger(values, period, mult) {
    if (!values || values.length < period || !values.every(v => Number.isFinite(v))) {
      console.warn(`calcBollinger failed: period=${period}, length=${values.length}`);
      return { upper: 0, middle: 0, lower: 0 };
    }
    const slice = values.slice(-period);
    const mean = slice.reduce((a, b) => a + b) / period;
    const variance = slice.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / period;
    const stddev = Math.sqrt(variance);
    return {
      upper: Number.isFinite(mean + mult * stddev) ? mean + mult * stddev : 0,
      middle: Number.isFinite(mean) ? mean : 0,
      lower: Number.isFinite(mean - mult * stddev) ? mean - mult * stddev : 0
    };
  }

  function calcATR(highs, lows, closes, period = 14) {
    if (!highs || !lows || !closes || highs.length < period + 1 || lows.length < period + 1 || closes.length < period + 1) {
        // console.log(`calcATR: Insufficient input data. Highs: ${highs ? highs.length : 0}, Lows: ${lows ? lows.length : 0}, Closes: ${closes ? closes.length : 0}. Required: ${period + 1}`);
        return NaN; // Return NaN to propagate problem clearly
    }
    // console.log(`calcATR: Calculating for ${highs.length} values.`);

    const trs = [];
    for (let i = 1; i < highs.length; i++) {
      const h = highs[i];
      const l = lows[i];
      const prevC = closes[i - 1];
      
      // Ensure all values are finite before calculating TR
      if (!Number.isFinite(h) || !Number.isFinite(l) || !Number.isFinite(prevC)) {
          trs.push(NaN); // Push NaN if any component is invalid
          continue;
      }
      const tr = Math.max(h - l, Math.abs(h - prevC), Math.abs(l - prevC));
      trs.push(tr);
    }
    // console.log(`calcATR: TRs array length: ${trs.length}, last 5: ${trs.slice(-5)}`);

    const atrArray = calcEMA(trs, period); // calcEMA now returns an array
    const atr = getLastValidValue(atrArray);
    // console.log(`calcATR: ATR Array (last 5): ${atrArray.slice(-5)}`);
    // console.log(`calcATR: Final Latest ATR: ${atr}`);

    // Return NaN if ATR is not finite or non-positive. `analyzeData`'s `effectiveATR` will handle fallback.
    return Number.isFinite(atr) && atr > 0 ? atr : NaN; 
  }
  
  function calcADX(highs, lows, closes, period) {
    if (highs.length < period + 1) return 0;
    let plusDM = 0, minusDM = 0, tr = 0;
    for (let i = 1; i < highs.length; i++) {
      const upMove = highs[i] - highs[i - 1];
      const downMove = lows[i - 1] - lows[i];
      plusDM += (upMove > downMove && upMove > 0) ? upMove : 0;
      minusDM += (downMove > upMove && downMove > 0) ? downMove : 0;
      tr += Math.max(highs[i] - lows[i], Math.abs(highs[i] - closes[i - 1]), Math.abs(lows[i] - closes[i - 1]));
    }
    const plusDI = (plusDM / tr) * 100;
    const minusDI = (minusDM / tr) * 100;
    const dx = Math.abs(plusDI - minusDI) / (plusDI + minusDI) * 100;
    return Number.isFinite(dx) ? dx : 0;
  }

  function calcCCI(highs, lows, closes, period) {
    if (highs.length < period) return 0;
    const typical = highs.map((h, i) => (h + lows[i] + closes[i]) / 3);
    const tpSlice = typical.slice(-period);
    const mean = tpSlice.reduce((a, b) => a + b) / period;
    const meanDev = tpSlice.reduce((a, b) => a + Math.abs(b - mean), 0) / period;
    return meanDev === 0 ? 0 : (typical.at(-1) - mean) / (0.015 * meanDev);
  }

  function calcSAR(highs, lows, step, maxStep) {
    if (highs.length < 2) return 0;
    let sar = lows[0];
    let ep = highs[0];
    let af = step;
    let uptrend = true;
    for (let i = 1; i < highs.length; i++) {
      sar = sar + af * (ep - sar);
      if (uptrend) {
        if (highs[i] > ep) { ep = highs[i]; af = Math.min(af + step, maxStep); }
        if (lows[i] < sar) { uptrend = false; sar = ep; ep = lows[i]; af = step; }
      } else {
        if (lows[i] < ep) { ep = lows[i]; af = Math.min(af + step, maxStep); }
        if (highs[i] > sar) { uptrend = true; sar = ep; ep = highs[i]; af = step; }
      }
    }
    return Number.isFinite(sar) ? sar : 0;
  }

  function calcVWAP(highs, lows, closes, volumes) {
    let cumPV = 0, cumVol = 0;
    for (let i = 0; i < closes.length; i++) {
      const typicalPrice = (highs[i] + lows[i] + closes[i]) / 3;
      cumPV += typicalPrice * volumes[i];
      cumVol += volumes[i];
    }
    return cumVol === 0 ? 0 : cumPV / cumVol;
  }

  function calcIchimoku(closes, highs, lows, tenkanPeriod = 9, kijunPeriod = 26) {
    if (closes.length < kijunPeriod) return { tenkan: 0, kijun: 0 };
    const tenkanHigh = highs.slice(-tenkanPeriod);
    const tenkanLow = lows.slice(-tenkanPeriod);
    const kijunHigh = highs.slice(-kijunPeriod);
    const kijunLow = lows.slice(-kijunPeriod);
    const tenkan = (Math.max(...tenkanHigh) + Math.min(...tenkanLow)) / 2;
    const kijun = (Math.max(...kijunHigh) + Math.min(...kijunLow)) / 2;
    return { tenkan: Number.isFinite(tenkan) ? tenkan : 0, kijun: Number.isFinite(kijun) ? kijun : 0 };
  }

  function calcVolumeOscillator(volumes, shortPeriod = 5, longPeriod = 20) {
    if (volumes.length < longPeriod) return 0;
    const shortEMA = calcEMA(volumes, shortPeriod);
    const longEMA = calcEMA(volumes, longPeriod);
    return longEMA === 0 ? 0 : ((shortEMA - longEMA) / longEMA) * 100;
  }
  
// New Market Trend function for Bitcoin
function calcMarketTrend(closes) {
    if (!closes || closes.length < 50) {
        return 0; // Return 0 if not enough data for EMA50
    }
    const ema20 = getLastValidValue(calcEMA(closes, 20));
    const ema50 = getLastValidValue(calcEMA(closes, 50));
    const lastClose = closes[closes.length - 1];

    if (!Number.isFinite(ema20) || !Number.isFinite(ema50) || !Number.isFinite(lastClose)) {
        return 0;
    }

    if (ema20 > ema50 && lastClose > ema20) {
        return 10; // Strong Bullish Trend
    } else if (ema20 > ema50 && lastClose > ema50) {
        return 5;  // Moderate Bullish Trend
    } else if (ema20 < ema50 && lastClose < ema20) {
        return -10; // Strong Bearish Trend
    } else if (ema20 < ema50 && lastClose < ema50) {
        return -5;  // Moderate Bearish Trend
    } else {
        return 0;  // Neutral or Choppy
    }
}
  
  // New Volume Profile function (more nuanced)
function calcVolumeProfile(closes, highs, lows, volumes, numNodes = 10) {
    if (!closes || !highs || !lows || !volumes || closes.length === 0 || volumes.length === 0) {
        return { bullish_score: 0, bearish_score: 0 };
    }

    const prices = highs.concat(lows);
    const minPrice = Math.min(...prices);
    const maxPrice = Math.max(...prices);
    const priceRange = maxPrice - minPrice;
    if (priceRange === 0) {
        return { bullish_score: 0, bearish_score: 0 };
    }
    const nodeSize = priceRange / numNodes;

    const volumeNodes = Array(numNodes).fill(0);
    const nodePrices = Array(numNodes).fill(0);

    for (let i = 0; i < numNodes; i++) {
        nodePrices[i] = minPrice + (i * nodeSize);
    }

    for (let i = 0; i < highs.length; i++) {
        const h = highs[i];
        const l = lows[i];
        const v = volumes[i];
        const midPrice = (h + l) / 2;
        const nodeIndex = Math.floor((midPrice - minPrice) / nodeSize);
        if (nodeIndex >= 0 && nodeIndex < numNodes) {
            volumeNodes[nodeIndex] += v;
        }
    }

    const maxVolume = Math.max(...volumeNodes);
    if (maxVolume === 0) {
        return { bullish_score: 0, bearish_score: 0 };
    }
    const highVolumeNodeIndex = volumeNodes.findIndex(v => v === maxVolume);
    const highVolumeNodePrice = nodePrices[highVolumeNodeIndex];
    const currentPrice = closes[closes.length - 1];

    let bullishScore = 0;
    let bearishScore = 0;

    // Logic for scoring:
    // Bullish: Price is near or below the HVN (acting as support)
    if (currentPrice >= highVolumeNodePrice * 0.995 && currentPrice <= highVolumeNodePrice * 1.005) {
        bullishScore = Math.round((maxVolume > 0) ? (volumeNodes[highVolumeNodeIndex] / maxVolume) * 5 : 0);
    } else if (currentPrice < highVolumeNodePrice) {
        bullishScore = Math.round((maxVolume > 0) ? (volumeNodes[highVolumeNodeIndex] / maxVolume) * 3 : 0);
    }

    // Bearish: Price is near or above the HVN (acting as resistance)
    if (currentPrice >= highVolumeNodePrice * 0.995 && currentPrice <= highVolumeNodePrice * 1.005) {
        bearishScore = Math.round((maxVolume > 0) ? (volumeNodes[highVolumeNodeIndex] / maxVolume) * 5 : 0);
    } else if (currentPrice > highVolumeNodePrice) {
        bearishScore = Math.round((maxVolume > 0) ? (volumeNodes[highVolumeNodeIndex] / maxVolume) * 3 : 0);
    }

    return { bullish_score: bullishScore, bearish_score: bearishScore };
    }

   function updateDashboard(filteredResults, allResults) {
    const sections = {
      "Strong Buy": document.getElementById('strong-buy-body'),
      "Strong Sell": document.getElementById('strong-sell-body')
    };

    // Clear existing rows in both tables
    Object.values(sections).forEach(body => body.innerHTML = '');

    const sorted = { "Strong Buy": [], "Strong Sell": [] };
    filteredResults.forEach(r => {
      if (sorted[r.signal]) sorted[r.signal].push(r);
    });

    // Update the headers of the tables to include the Volume Profile score
    document.getElementById('strong-buy-section').getElementsByTagName('thead')[0].innerHTML = `
        <tr><th>Coin</th><th>Price</th><th>TP</th><th>SL</th><th>Leverage</th><th>POP</th><th>RSI</th><th>Vol Profile</th><th>Estimated Profit</th></tr>
    `;
    document.getElementById('strong-sell-section').getElementsByTagName('thead')[0].innerHTML = `
        <tr><th>Coin</th><th>Price</th><th>TP</th><th>SL</th><th>Leverage</th><th>POP</th><th>RSI</th><th>Vol Profile</th><th>Estimated Profit</th></tr>
    `;

    for (let key in sorted) {
      if (sorted[key].length > 0) {
        // Sort by absolute value of profit for cleaner dashboard display
        sorted[key].sort((a, b) => {
            const profitA = parseFloat(a.estimated_profit.replace('%', ''));
            const profitB = parseFloat(b.estimated_profit.replace('%', ''));
            return Math.abs(profitB) - Math.abs(profitA);
        });
        
        sorted[key].forEach((r, index) => {
          const popClass = r.pop >= 70 ? 'pop-high' : (r.pop >= 50 ? 'pop-medium' : 'pop-low');
          const topClass = index < 3 ? (key.includes("Sell") ? "top-pick-sell" : "top-pick") : "";

          // Get the Volume Profile score for the dashboard
          const volProfileScore = (key.includes("Buy")) ? r.volProfile.bullish_score : r.volProfile.bearish_score;
          const volProfileClass = volProfileScore >= 4 ? 'pop-high' : (volProfileScore === 3 ? 'pop-medium' : 'pop-low');
          
          // Remove the negative sign for display in the dashboard table
          const displayProfit = r.estimated_profit.replace('-', '');

          const row = `<tr class="${topClass}">
            <td>${r.coin.replace('USDT','')}</td>
            <td>$${r.price.toFixed(4)}</td>
            <td>${r.tp}</td>
            <td>${r.sl}</td>
            <td>${r.leverage}</td>
            <td class="${popClass}">${r.pop}%</td>
            <td>${r.rsi.toFixed(2)}</td>
            <td class="${volProfileClass}">${volProfileScore}</td>
            <td class="bold">${displayProfit}</td>
          </tr>`;
          sections[key].innerHTML += row;
        });
      }
    }
  }
  function updateRawData(results) {
    document.getElementById('raw-data').value = JSON.stringify(results, null, 2);
  }

  function startSpinner(show) {
    document.getElementById('spinner').style.display = show ? 'inline-block' : 'none';
    document.getElementById('refresh-btn').disabled = show;
  }

  function updateProgress(percent) {
    document.getElementById('progress-bar').style.width = percent + "%";
  }

  function startCountdown(seconds) {
    const countdownEl = document.getElementById('countdown');
    let remaining = seconds;
    countdownEl.textContent = formatTime(remaining);
    countdownInterval = setInterval(() => {
      remaining--;
      countdownEl.textContent = formatTime(remaining);
      if (remaining <= 0) clearInterval(countdownInterval);
    }, 1000);
  }

  function formatTime(sec) {
    const m = String(Math.floor(sec / 60)).padStart(2, '0');
    const s = String(sec % 60).padStart(2, '0');
    return `${m}:${s}`;
  }

  fetchData();
</script>
</body>
</html>






















