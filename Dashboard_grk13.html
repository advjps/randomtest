<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>Crypto Dashboard — 8th Amendment</title>
<script src="https://cdn.tailwindcss.com"></script>
<style>
  :root { color-scheme: dark; }
  body { background: #0b1220; }
  .card{background:#0f172a;border:1px solid #1f2937;border-radius:14px}
  .badge{display:inline-block;padding:.15rem .5rem;border-radius:.5rem;font-weight:600;border:1px solid #374151}
  .badge-strong{background:#111827;color:#93c5fd;border-color:#334155}
  .badge-buy{background:#052e16;color:#86efac;border-color:#064e3b}
  .badge-sell{background:#3f1d1d;color:#fca5a5;border-color:#7f1d1d}
  .badge-regime{background:#0b1220;color:#e5e7eb;border-color:#374151}
  .chip{padding:.15rem .45rem;border-radius:.45rem;border:1px solid #334155;background:#0b1220}
  table th{position:sticky;top:0;background:#0b1220}
  .mono{font-variant-numeric:tabular-nums}
</style>
</head>
<body class="text-slate-100">
<div class="max-w-7xl mx-auto p-4 space-y-4">

  <!-- Header -->
  <header class="flex flex-wrap items-center justify-between gap-3">
    <div>
      <h1 class="text-xl font-semibold">Crypto Trading Signals <span class="text-slate-400 text-sm">— 8th Amendment</span></h1>
      <p class="text-xs text-slate-400 mt-1">Client-side: pulls Binance Futures, runs indicators, regime, confidence & widening locally.</p>
      <div class="text-xs text-slate-400 mt-1">
        <span>Last Updated: <span id="lastUpdated">--:--</span></span>
        <span class="mx-2">•</span>
        <span>Symbols: <span id="statSymbols">0</span></span>
      </div>
    </div>
    <div class="flex items-center gap-2">
      <button id="btnRefresh" class="px-3 py-2 rounded-lg bg-slate-800 hover:bg-slate-700 border border-slate-700">Refresh</button>
      <button id="btnCopy" class="px-3 py-2 rounded-lg bg-slate-800 hover:bg-slate-700 border border-slate-700">Copy JSON</button>
      <a id="btnDownload" download="live_signals.json" class="px-3 py-2 rounded-lg bg-indigo-600 hover:bg-indigo-500">Download JSON</a>
    </div>
  </header>

  <!-- Regime -->
  <section id="regimeBar" class="card p-3 hidden">
    <div class="badge badge-regime" id="regimeBadge">Regime: …</div>
    <span class="ml-2 text-xs text-slate-400" id="regimeExplain"></span>
  </section>

  <!-- KPIs -->
  <section class="grid md:grid-cols-4 gap-3">
    <div class="card p-3">
      <div class="text-xs text-slate-400">Total Signals</div>
      <div class="text-2xl font-semibold" id="statTotal">0</div>
    </div>
    <div class="card p-3">
      <div class="text-xs text-slate-400">Strong Signals</div>
      <div class="text-2xl font-semibold" id="statStrong">0</div>
    </div>
    <div class="card p-3">
      <div class="text-xs text-slate-400">Avg Confidence</div>
      <div class="text-2xl font-semibold" id="statAvgConf">--</div>
    </div>
    <div class="card p-3">
      <div class="text-xs text-slate-400">Strong Rate</div>
      <div class="text-2xl font-semibold" id="statStrongRate">--</div>
    </div>
  </section>

  <!-- Filters -->
  <section class="card p-3">
    <div class="flex flex-wrap items-center gap-2">
      <label class="text-sm text-slate-300">Filter:</label>
      <select id="filterType" class="bg-slate-900 border border-slate-700 rounded-lg px-2 py-1 text-sm">
        <option value="all">All</option>
        <option value="strong">Strong only</option>
        <option value="buy">Buy side</option>
        <option value="sell">Sell side</option>
        <option value="neutral">Neutral</option>
      </select>
      <label class="text-sm text-slate-300 ml-3">Min Confidence:</label>
      <input id="minConf" type="number" min="0" max="100" value="0" class="bg-slate-900 border border-slate-700 rounded-lg px-2 py-1 w-20 text-sm" />
      <label class="text-sm text-slate-300 ml-3">Search:</label>
      <input id="searchBox" type="text" placeholder="e.g., BTCUSDT…" class="bg-slate-900 border border-slate-700 rounded-lg px-2 py-1 text-sm w-48" />
      <div class="ml-auto flex items-center gap-2">
        <span class="text-xs text-slate-500">Sort by</span>
        <select id="sortBy" class="bg-slate-900 border border-slate-700 rounded-lg px-2 py-1 text-sm">
          <option value="confidence">Confidence</option>
          <option value="estimated_profit">Est. Profit</option>
          <option value="rsi">RSI</option>
          <option value="price">Price</option>
          <option value="coin">Coin</option>
        </select>
        <select id="sortDir" class="bg-slate-900 border border-slate-700 rounded-lg px-2 py-1 text-sm">
          <option value="desc">⬇</option>
          <option value="asc">⬆</option>
        </select>
      </div>
    </div>
  </section>

  <!-- Strong tables -->
  <section class="grid md:grid-cols-2 gap-4">
    <div class="card p-3">
      <h2 class="text-lg font-semibold mb-2">Strong Buy</h2>
      <div class="overflow-auto max-h-[60vh]">
        <table class="w-full text-sm">
          <thead>
            <tr class="text-slate-300">
              <th class="text-left p-2">Coin</th>
              <th class="text-right p-2">Price</th>
              <th class="text-right p-2">TP</th>
              <th class="text-right p-2">SL</th>
              <th class="text-center p-2">Lev</th>
              <th class="text-center p-2">Conf</th>
              <th class="text-center p-2">RSI</th>
              <th class="text-center p-2">Est. Profit</th>
              <th class="text-center p-2">Notes</th>
            </tr>
          </thead>
          <tbody id="tbodyStrongBuy"></tbody>
        </table>
      </div>
    </div>
    <div class="card p-3">
      <h2 class="text-lg font-semibold mb-2">Strong Sell</h2>
      <div class="overflow-auto max-h-[60vh]">
        <table class="w-full text-sm">
          <thead>
            <tr class="text-slate-300">
              <th class="text-left p-2">Coin</th>
              <th class="text-right p-2">Price</th>
              <th class="text-right p-2">TP</th>
              <th class="text-right p-2">SL</th>
              <th class="text-center p-2">Lev</th>
              <th class="text-center p-2">Conf</th>
              <th class="text-center p-2">RSI</th>
              <th class="text-center p-2">Est. Profit</th>
              <th class="text-center p-2">Notes</th>
            </tr>
          </thead>
          <tbody id="tbodyStrongSell"></tbody>
        </table>
      </div>
    </div>
  </section>

  <!-- All signals -->
  <section class="card p-3">
    <h2 class="text-lg font-semibold mb-2">All Signals</h2>
    <div class="overflow-auto max-h-[70vh]">
      <table class="w-full text-sm">
        <thead>
          <tr class="text-slate-300">
            <th class="text-left p-2">Coin</th>
            <th class="text-center p-2">Signal</th>
            <th class="text-right p-2">Price</th>
            <th class="text-right p-2">TP</th>
            <th class="text-right p-2">SL</th>
            <th class="text-center p-2">Lev</th>
            <th class="text-center p-2">Conf</th>
            <th class="text-center p-2">%B</th>
            <th class="text-center p-2">RSI</th>
            <th class="text-center p-2">ADX15m</th>
            <th class="text-center p-2">Est. Profit</th>
            <th class="text-center p-2">Widened</th>
            <th class="text-center p-2">Confluence</th>
          </tr>
        </thead>
        <tbody id="tbodyAll"></tbody>
      </table>
    </div>
  </section>

  <footer class="text-xs text-slate-500 pb-6">
    8th Amendment: regime gating, confidence scoring, RSI boosts, adaptive 1:1 widening, no profit ceiling.
  </footer>
</div>

<script>
/* ================== CONFIG ================== */
const BINANCE = "https://fapi.binance.com";         // futures
const TOP_LIMIT = 70;
const USE_PROXY = false;                             // flip to true to force a CORS proxy
const PROXY = "https://cors.isomorphic-git.org/";    // simple passthrough proxy

// Profit evaluation basis (ROI on margin)
const LEVERAGE_FOR_PROFIT_EVAL = 7.0;
const MIN_PROFIT_MARGIN = 2.0;     // % on margin minimum
// Profit ceiling veto is removed in the 8th Amendment

// Strong thresholds by regime+side
const STRONG_CONF_THRESHOLDS = {
  Bearish_Sell: 70,
  Bullish_Buy: 78,
  Neutral_Sell: 75,
  Neutral_Buy: 80
};

// ATR-based TP/SL clamps (as fraction of price)
const TP_PCT_MIN = 0.008, TP_PCT_MAX = 0.016;
const SL_PCT_MIN = 0.008, SL_PCT_MAX = 0.020;

// Adaptive widening for extreme RSI contexts (keep 1:1)
const WIDEN_MIN_PCT = 0.012, WIDEN_MAX_PCT = 0.022;

// Regime hysteresis
const REGIME_HOLD_MINUTES = 60;
const REGIME_CONFIRM_BARS = 2;

/* ============== STATE ============== */
let RAW = [];
let LAST_JSON = "[]";

/* ============== UTILITIES ============== */
const $ = s => document.querySelector(s);
function fmt(n, d=2){ return (n==null || isNaN(+n)) ? "-" : (+n).toFixed(d); }
function proxyUrl(u){ return USE_PROXY ? PROXY + u : u; }
function sleep(ms){ return new Promise(r=>setTimeout(r, ms)); }

/* ============== FETCHERS ============== */
async function fetchJSON(url){
  const r = await fetch(proxyUrl(url), {cache:"no-store"});
  if(!r.ok) throw new Error("HTTP "+r.status);
  return r.json();
}
async function fetchTopVolumeCoins(limit=TOP_LIMIT){
  const data = await fetchJSON(`${BINANCE}/fapi/v1/ticker/24hr`);
  const usdt = data.filter(x => x.symbol?.endsWith("USDT"));
  usdt.sort((a,b)=>(+b.quoteVolume||0) - (+a.quoteVolume||0));
  return usdt.slice(0, limit).map(x=>x.symbol);
}
async function fetchKlines(symbol, interval='5m', limit=120){
  const url = `${BINANCE}/fapi/v1/klines?symbol=${symbol}&interval=${interval}&limit=${limit}`;
  const data = await fetchJSON(url);
  return data.map(d=>({
    openTime:+d[0],
    open:+d[1], high:+d[2], low:+d[3], close:+d[4],
    volume:+d[5], closeTime:+d[6]
  }));
}

/* ============== INDICATORS ============== */
function ema(values, span){
  const k = 2/(span+1);
  let ema=values[0], out=[ema];
  for(let i=1;i<values.length;i++){
    ema = values[i]*k + ema*(1-k);
    out.push(ema);
  }
  return out;
}
function rsi(closes, period=14){
  if(closes.length < period+1) return Array(closes.length).fill(null);
  const deltas = closes.map((v,i)=> i? v - closes[i-1] : 0);
  let gain=0, loss=0;
  for(let i=1;i<=period;i++){
    const d = deltas[i]; if(d>0) gain+=d; else loss-=d;
  }
  gain/=period; loss/=period;
  let rs = loss===0? 0 : gain/loss;
  const out = Array(period).fill(null);
  out.push(100 - 100/(1+rs));
  for(let i=period+1;i<closes.length;i++){
    const d = deltas[i];
    gain = (gain*(period-1) + (d>0?d:0))/period;
    loss = (loss*(period-1) + (d<0?-d:0))/period;
    rs = loss===0? 0 : gain/loss;
    out.push(100 - 100/(1+rs));
  }
  return out;
}
function macdHist(closes, fast=12, slow=26, signal=9){
  const emaFast = ema(closes, fast);
  const emaSlow = ema(closes, slow);
  const macdLine = emaFast.map((v,i)=> v - (emaSlow[i]??v));
  const signalLine = ema(macdLine.map(v=>v??0), signal);
  return macdLine.map((v,i)=> (v??0) - (signalLine[i]??0));
}
function bollinger(closes, period=20, mult=2){
  if(closes.length<period) return {upper:null,middle:null,lower:null};
  const ma = [];
  const sd = [];
  for(let i=0;i<closes.length;i++){
    const s = Math.max(0, i-period+1);
    const win = closes.slice(s, i+1);
    const mean = win.reduce((a,b)=>a+b,0)/win.length;
    const variance = win.reduce((a,b)=>a+(b-mean)*(b-mean),0)/win.length;
    const std = Math.sqrt(variance);
    ma.push(mean); sd.push(std);
  }
  const m = ma.at(-1), sdev = sd.at(-1);
  return { upper: m + mult*sdev, middle: m, lower: m - mult*sdev };
}
function atr(highs,lows,closes,period=14){
  if(closes.length < period+1) return null;
  const tr = [];
  for(let i=1;i<closes.length;i++){
    const hl = highs[i]-lows[i];
    const hc = Math.abs(highs[i]-closes[i-1]);
    const lc = Math.abs(lows[i]-closes[i-1]);
    tr.push(Math.max(hl,hc,lc));
  }
  // EMA of TR
  const k = 2/(period+1);
  let a = tr[0]; for(let i=1;i<tr.length;i++) a = tr[i]*k + a*(1-k);
  return a;
}
function cci(highs,lows,closes,period=20){
  if(closes.length < period) return null;
  const tp = closes.map((c,i)=>(highs[i]+lows[i]+closes[i])/3);
  const win = tp.slice(-period);
  const mean = win.reduce((a,b)=>a+b,0)/period;
  const md = win.reduce((a,b)=> a + Math.abs(b-mean), 0)/period;
  if(md===0) return 0;
  return (tp.at(-1)-mean)/(0.015*md);
}
// Simple ADX(14) on 5m data
function adx(highs,lows,closes,period=14){
  if(closes.length < period+2) return null;
  let tr=[], plusDM=[], minusDM=[];
  for(let i=1;i<closes.length;i++){
    const up = highs[i]-highs[i-1];
    const dn = lows[i-1]-lows[i];
    plusDM.push((up>dn && up>0)? up : 0);
    minusDM.push((dn>up && dn>0)? dn : 0);
    const _tr = Math.max(highs[i]-lows[i], Math.abs(highs[i]-closes[i-1]), Math.abs(lows[i]-closes[i-1]));
    tr.push(_tr);
  }
  // smooth with EMA
  const trE = ema(tr, period);
  const pE = ema(plusDM, period);
  const mE = ema(minusDM, period);
  const pDI = pE.map((v,i)=> 100*(v/(trE[i]||1e-9)));
  const mDI = mE.map((v,i)=> 100*(v/(trE[i]||1e-9)));
  const dx = pDI.map((v,i)=> {
    const a=v, b=mDI[i]||0;
    return 100*(Math.abs(a-b)/((a+b)||1e-9));
  });
  return ema(dx, period).at(-1);
}

/* ============== VOLUME PROFILE (coarse) ============== */
function volProfile(closes, highs, lows, volumes){
  try{
    const minP = Math.min(...lows), maxP = Math.max(...highs);
    const bins = 10, step = (maxP - minP)/(bins||1) || 1;
    const agg = Array(bins).fill(0);
    closes.forEach((p,i)=>{
      const idx = Math.min(bins-1, Math.max(0, Math.floor((p-minP)/step)));
      agg[idx] += (volumes[i]||0);
    });
    let maxIdx = 0; for(let i=1;i<bins;i++) if(agg[i]>agg[maxIdx]) maxIdx=i;
    const poc = minP + (maxIdx+0.5)*step;
    const current = closes.at(-1);
    if(current > poc) return {bullish_score:3, bearish_score:0};
    if(current < poc) return {bullish_score:0, bearish_score:3};
    return {bullish_score:5, bearish_score:5};
  }catch(e){
    return {bullish_score:1, bearish_score:1};
  }
}

/* ============== REGIME DETECTOR (BTC EMA20/50 + hysteresis) ============== */
function marketRegime(btcCloses){
  if(!btcCloses || btcCloses.length<50) return {regime:"Neutral", score:0, components:{}};
  const ema20 = ema(btcCloses, 20).at(-1);
  const ema50 = ema(btcCloses, 50).at(-1);
  const price = btcCloses.at(-1);
  let score = 0;
  if(ema20>ema50 && price>ema20) score = 10;
  else if(ema20>ema50) score = 5;
  else if(ema20<ema50 && price<ema20) score = -10;
  else if(ema20<ema50) score = -5;

  // hysteresis via localStorage (sticky for REGIME_HOLD_MINUTES if not strongly contradicted)
  const key="__regime_hold__";
  try{
    const now = Date.now();
    let hold = JSON.parse(localStorage.getItem(key)||"null");
    const strong = (Math.abs(score)>=10);
    if(!hold){
      hold = {regime: score>0?"Bullish": (score<0?"Bearish":"Neutral"), score, ts: now, confirmBars: 1};
    }else{
      const newReg = score>0?"Bullish": (score<0?"Bearish":"Neutral");
      if(newReg === hold.regime){
        hold.score = score; hold.ts = now; hold.confirmBars = Math.min(hold.confirmBars+1, REGIME_CONFIRM_BARS);
      }else{
        // require confirmations or hold window to pass
        if(strong || hold.confirmBars>=REGIME_CONFIRM_BARS || (now - hold.ts) > REGIME_HOLD_MINUTES*60*1000){
          hold.regime = newReg; hold.score = score; hold.ts = now; hold.confirmBars = 1;
        } // else keep old
      }
    }
    localStorage.setItem(key, JSON.stringify(hold));
    return {regime: hold.regime, score: hold.score, components:{ema20,ema50,price}};
  }catch(e){
    return {regime: score>0?"Bullish": (score<0?"Bearish":"Neutral"), score, components:{ema20,ema50,price}};
  }
}

/* ============== ANALYZE (8th Amendment) ============== */
function analyzeData(symbol, data5m, regimeObj){
  if(!data5m || data5m.length<60) return null;
  const price = data5m.at(-1).close;
  const closes = data5m.map(d=>d.close);
  const highs  = data5m.map(d=>d.high);
  const lows   = data5m.map(d=>d.low);
  const vols   = data5m.map(d=>d.volume);

  const rsiArr  = rsi(closes,14); const rsi5 = rsiArr.at(-1);
  const macdH   = macdHist(closes,12,26,9).at(-1);
  const boll    = bollinger(closes,20,2);
  const atrVal  = atr(highs,lows,closes,14) ?? price*0.002;
  const cciVal  = cci(highs,lows,closes,20);
  const ema50   = ema(closes,50).at(-1);
  const adx5    = adx(highs,lows,closes,14);
  const volp    = volProfile(closes,highs,lows,vols);

  if([rsi5, cciVal, boll.lower, boll.upper].some(v=>v==null)) return null;

  const percentB = (()=>{
    const rng = (boll.upper - boll.lower) || 1e-9;
    return (price - boll.lower)/rng;
  })();

  const regime = regimeObj?.regime || "Neutral";
  const regimeScore = regimeObj?.score ?? 0;

  // Scoring
  let buyScore=0, sellScore=0;
  if(price <= boll.lower) buyScore+=35;
  if(rsi5 <=30) buyScore+=30; else if(rsi5<=40) buyScore+=15;
  if(cciVal >=100) buyScore+=15;
  if(macdH<0) buyScore+=5;
  if(price>=ema50) buyScore+=10;

  if(price >= boll.upper) sellScore+=35;
  if(rsi5 >=70) sellScore+=30; else if(rsi5>=60) sellScore+=15;
  if(cciVal <=-100) sellScore+=15;
  if(macdH>0) sellScore+=5;
  if(price<=ema50) sellScore+=10;

  if(regime==="Bullish"){ buyScore+=10; sellScore-=10; }
  else if(regime==="Bearish"){ sellScore+=10; buyScore-=10; }

  // Regime gating
  let initial="Neutral";
  if(regime==="Bullish"){ if(buyScore>0) initial="Buy"; }
  else if(regime==="Bearish"){ if(sellScore>0) initial="Sell"; }
  else { if(buyScore>sellScore && buyScore>0) initial="Buy"; else if(sellScore>buyScore && sellScore>0) initial="Sell"; }
  if(initial==="Neutral"){
    return {
      coin:symbol, price, tp:price, sl:price, leverage:"5x", confidence:0, signal:"Neutral",
      estimated_profit:"0.00%",
      analysis_log:{initial_signal:"Neutral", regime, regime_score:regimeScore, num_confluence_met:0, vol_profile_ok:false, overshoot_ok:false, min_profit_ok:false, adaptive_widen_applied:false},
      indicators:{rsi5m:rsi5, macd_hist5m:macdH, boll5m:boll, cci5m:cciVal, ema50_5m:ema50, adx15m:adx5, percentB, marketRegime:regime, regimeScore:regimeScore, volProfile:volp}
    };
  }

  // Confluence & overshoot
  const bbTouchBuy = price<=boll.lower, bbTouchSell = price>=boll.upper;
  const rsiBuy = rsi5<=30, rsiSell = rsi5>=70;
  const cciBuy = cciVal>=100, cciSell = cciVal<=-100;

  const numConfBuy  = (bbTouchBuy?1:0) + (rsiBuy?1:0) + (cciBuy?1:0);
  const numConfSell = (bbTouchSell?1:0)+ (rsiSell?1:0)+ (cciSell?1:0);

  const volOkBuy  = (volp.bullish_score>0), volOkSell = (volp.bearish_score>0);
  const overshootBuy  = (percentB<=0.05) || rsi5<=28 || bbTouchBuy;
  const overshootSell = (percentB>=0.95) || rsi5>=72 || bbTouchSell;

  const baseBuyOk  = buyScore>=18, baseSellOk = sellScore>=18;
  const confBuyOk  = numConfBuy >= (regime!=="Neutral"?2:3);
  const confSellOk = numConfSell>= (regime!=="Neutral"?2:3);

  // Risk & widening
  const aligned = (regime==="Bullish" && initial==="Buy") || (regime==="Bearish" && initial==="Sell");
  const tpFactor = aligned? 2.2 : 2.0;
  const slFactor = aligned? 1.8 : 2.0;

  let tpRaw, slRaw;
  if(initial==="Buy"){ tpRaw = price + atrVal*tpFactor; slRaw = price - atrVal*slFactor; }
  else { tpRaw = price - atrVal*tpFactor; slRaw = price + atrVal*slFactor; }

  let tpPct = Math.abs((tpRaw-price)/price);
  let slPct = Math.abs((slRaw-price)/price);

  tpPct = Math.min(Math.max(tpPct, TP_PCT_MIN), TP_PCT_MAX);
  slPct = Math.min(Math.max(slPct, SL_PCT_MIN), SL_PCT_MAX);

  const sellExtreme = (initial==="Sell" && rsi5>=70 && ((percentB>=0.95)||bbTouchSell) && (macdH<=0 || (adx5??0)>=20));
  const buyExtreme  = (initial==="Buy"  && rsi5<=30 && ((percentB<=0.05)||bbTouchBuy)  && (macdH>=0 || (adx5??0)>=20));
  let adaptiveWiden=false;
  if(sellExtreme || buyExtreme){
    let pct = Math.max(tpPct, slPct);
    pct = Math.min(Math.max(pct, WIDEN_MIN_PCT), WIDEN_MAX_PCT);
    tpPct = pct; slPct = pct; adaptiveWiden = true;
  }

  const tp = initial==="Buy" ? price*(1+tpPct) : price*(1-tpPct);
  const sl = initial==="Buy" ? price*(1-slPct) : price*(1+slPct);

  const rawMovePct = tpPct*100;
  const estProfitMarginPct = rawMovePct*LEVERAGE_FOR_PROFIT_EVAL;
  const minProfitOk = estProfitMarginPct >= MIN_PROFIT_MARGIN;

  // Confidence
  const base = initial==="Buy"? buyScore : sellScore;
  const numConf = initial==="Buy"? numConfBuy : numConfSell;
  const volOk = initial==="Buy"? volOkBuy : volOkSell;
  const overshootOk = initial==="Buy"? overshootBuy : overshootSell;

  const baseComp = Math.max(0, Math.min(1, base/100))*0.40;
  const confComp = Math.max(0, Math.min(1, numConf/3))*0.40;
  let vetoPass = 0;
  if((initial==="Buy"? baseBuyOk:baseSellOk)) vetoPass++;
  if(volOk) vetoPass++;
  if(minProfitOk) vetoPass++;
  const vetoComp = (vetoPass/3)*0.20;

  let confidence = Math.round((baseComp+confComp+vetoComp)*100);
  confidence = Math.max(0, Math.min(100, confidence));

  // RSI-based boosts (with MACD fail-safes)
  let rsiBoost = 0;
  if(initial==="Sell" && rsi5>=70 && !(macdH>0)){
    rsiBoost += 6; if(percentB>=0.95 || bbTouchSell) rsiBoost += 3;
  }
  if(initial==="Buy" && rsi5<=30 && !(macdH<0)){
    rsiBoost += 6; if(percentB<=0.05 || bbTouchBuy) rsiBoost += 3;
  }
  if(rsiBoost) confidence = Math.max(0, Math.min(100, confidence + rsiBoost));

  // Final label (adaptive thresholds)
  let strongSellThr, strongBuyThr;
  if(regime==="Bearish"){ strongSellThr=STRONG_CONF_THRESHOLDS.Bearish_Sell; strongBuyThr=STRONG_CONF_THRESHOLDS.Neutral_Buy; }
  else if(regime==="Bullish"){ strongSellThr=STRONG_CONF_THRESHOLDS.Neutral_Sell; strongBuyThr=STRONG_CONF_THRESHOLDS.Bullish_Buy; }
  else { strongSellThr=STRONG_CONF_THRESHOLDS.Neutral_Sell; strongBuyThr=STRONG_CONF_THRESHOLDS.Neutral_Buy; }

  let final="Neutral";
  if(initial==="Buy"){
    if(baseBuyOk && confComp>0 && volOk && overshootOk && minProfitOk && confidence>=strongBuyThr) final="Strong Buy";
    else if(confidence>=40) final="Buy"; else final="Neutral";
  }else{
    if(baseSellOk && confComp>0 && volOk && overshootOk && minProfitOk && confidence>=strongSellThr) final="Strong Sell";
    else if(confidence>=40) final="Sell"; else final="Neutral";
  }

  const leverage = final.startsWith("Strong") ? "7x" : (confidence>=50 ? "6x" : "5x");
  return {
    coin: symbol,
    price: +price.toFixed(6),
    tp: +tp.toFixed(6),
    sl: +sl.toFixed(6),
    leverage,
    confidence,
    signal: final,
    estimated_profit: `${estProfitMarginPct.toFixed(2)}%`,
    analysis_log:{
      initial_signal: initial,
      regime, regime_score: regimeScore,
      num_confluence_met: numConf,
      vol_profile_ok: !!volOk,
      overshoot_ok: !!overshootOk,
      min_profit_ok: !!minProfitOk,
      adaptive_widen_applied: !!adaptiveWiden,
      rsi_conf_boost_points: rsiBoost,
      buy_score: Math.round(buyScore),
      sell_score: Math.round(sellScore),
    },
    indicators:{
      rsi5m:rsi5,
      macd_hist5m:macdH,
      boll5m: {upper:boll.upper, middle:boll.middle, lower:boll.lower},
      cci5m: cciVal,
      ema50_5m: ema50,
      adx15m: adx5,
      percentB,
      marketRegime: regime,
      regimeScore: regimeScore,
      volProfile: volp
    }
  };
}

/* ============== RENDERING ============== */
function clsSignal(sig){
  if(!sig) return "badge";
  if(sig.startsWith("Strong")) return "badge badge-strong";
  if(sig.includes("Buy")) return "badge badge-buy";
  if(sig.includes("Sell")) return "badge badge-sell";
  return "badge";
}
function noteFlags(row){
  const n=[];
  if(row?.analysis_log?.adaptive_widen_applied) n.push("Widened");
  const nc = row?.analysis_log?.num_confluence_met;
  if(typeof nc==="number") n.push(`Conf ${nc}`);
  return n.join(", ");
}
function renderStats(rows){
  const strongs = rows.filter(r=>r.signal.startsWith("Strong"));
  $("#statTotal").textContent = rows.length;
  $("#statStrong").textContent = strongs.length;
  const avg = rows.length? (rows.reduce((a,b)=>a+(+b.confidence||0),0)/rows.length) : 0;
  $("#statAvgConf").textContent = fmt(avg,1) + "%";
  $("#statStrongRate").textContent = rows.length? fmt((strongs.length/rows.length)*100,1) + "%" : "--";
}
function fillTable(tbody, arr){
  tbody.innerHTML = "";
  arr.forEach(x=>{
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="p-2">${x.coin}</td>
      <td class="p-2 text-right mono">${fmt(x.price,4)}</td>
      <td class="p-2 text-right mono">${fmt(x.tp,4)}</td>
      <td class="p-2 text-right mono">${fmt(x.sl,4)}</td>
      <td class="p-2 text-center">${x.leverage||"-"}</td>
      <td class="p-2 text-center"><span class="chip">${x.confidence??"-"}</span></td>
      <td class="p-2 text-center mono">${fmt(x.indicators?.rsi5m,1)}</td>
      <td class="p-2 text-center">${x.estimated_profit||"-"}</td>
      <td class="p-2 text-center">${noteFlags(x)}</td>
    `;
    tbody.appendChild(tr);
  });
}
function renderAll(rows, regimeObj){
  // regime bar
  if(regimeObj){
    $("#regimeBar").classList.remove("hidden");
    $("#regimeBadge").textContent = `Regime: ${regimeObj.regime} (${fmt(regimeObj.score,0)})`;
    $("#regimeExplain").textContent = `EMA20/50 on BTC, price=${fmt(regimeObj.components?.price,2)}`;
  }
  renderStats(rows);

  const sb = rows.filter(r=>r.signal==="Strong Buy");
  const ss = rows.filter(r=>r.signal==="Strong Sell");
  fillTable($("#tbodyStrongBuy"), sb);
  fillTable($("#tbodyStrongSell"), ss);

  applyFiltersAndRender(rows);
}
function getSortVal(x, key){
  switch(key){
    case "confidence": return +(x.confidence||0);
    case "estimated_profit": return parseFloat((x.estimated_profit||"0").toString().replace("%","")) || 0;
    case "rsi": return +(x.indicators?.rsi5m||0);
    case "price": return +(x.price||0);
    case "coin": return (x.coin||"");
    default: return +(x.confidence||0);
  }
}
function applyFiltersAndRender(rows){
  const type = $("#filterType").value;
  const minC = +$("#minConf").value || 0;
  const q = $("#searchBox").value.trim().toUpperCase();
  const sortKey = $("#sortBy").value;
  const dir = $("#sortDir").value;

  let arr = rows.slice();
  if(type==="strong") arr = arr.filter(s=>s.signal.startsWith("Strong"));
  if(type==="buy")    arr = arr.filter(s=>/Buy/.test(s.signal));
  if(type==="sell")   arr = arr.filter(s=>/Sell/.test(s.signal));
  if(type==="neutral")arr = arr.filter(s=>/Neutral/.test(s.signal));
  arr = arr.filter(s => (+s.confidence||0) >= minC);
  if(q) arr = arr.filter(s => (s.coin||"").toUpperCase().includes(q));

  arr.sort((a,b)=>{
    const va = getSortVal(a, sortKey), vb = getSortVal(b, sortKey);
    if(va===vb) return 0;
    return (dir==="asc") ? (va>vb?1:-1) : (va<vb?1:-1);
  });

  const tbody = $("#tbodyAll"); tbody.innerHTML = "";
  arr.forEach(x=>{
    const pctB = x.indicators?.percentB;
    const nc = x.analysis_log?.num_confluence_met;
    const widened = x.analysis_log?.adaptive_widen_applied ? "Yes" : "No";
    const tr = document.createElement("tr");
    tr.innerHTML = `
      <td class="p-2">${x.coin}</td>
      <td class="p-2 text-center"><span class="${clsSignal(x.signal)}">${x.signal}</span></td>
      <td class="p-2 text-right mono">${fmt(x.price,4)}</td>
      <td class="p-2 text-right mono">${fmt(x.tp,4)}</td>
      <td class="p-2 text-right mono">${fmt(x.sl,4)}</td>
      <td class="p-2 text-center">${x.leverage||"-"}</td>
      <td class="p-2 text-center"><span class="chip">${x.confidence??"-"}</span></td>
      <td class="p-2 text-center mono">${pctB==null? "-" : fmt(pctB,3)}</td>
      <td class="p-2 text-center mono">${fmt(x.indicators?.rsi5m,1)}</td>
      <td class="p-2 text-center mono">${fmt(x.indicators?.adx15m,0)}</td>
      <td class="p-2 text-center">${x.estimated_profit||"-"}</td>
      <td class="p-2 text-center">${widened}</td>
      <td class="p-2 text-center">${nc??"-"}</td>
    `;
    tbody.appendChild(tr);
  });
}

/* ============== CONTROLLER ============== */
async function runOnce(){
  $("#lastUpdated").textContent = new Date().toLocaleTimeString();

  // 1) BTC for regime
  const btc5 = await fetchKlines("BTCUSDT","5m",120);
  const btcCloses = btc5.map(d=>d.close);
  const regimeObj = marketRegime(btcCloses);

  // 2) Top coins
  const symbols = await fetchTopVolumeCoins(TOP_LIMIT);
  $("#statSymbols").textContent = symbols.length;

  // 3) Per-coin 5m klines & analyze
  const rows = [];
  for(let i=0;i<symbols.length;i++){
    const s = symbols[i];
    try{
      const data5m = await fetchKlines(s,"5m",120);
      const res = analyzeData(s, data5m, regimeObj);
      if(res) rows.push(res);
      // small delay to be polite
      await sleep(40);
    }catch(e){
      console.warn("Error coin", s, e);
    }
  }

  RAW = rows;
  LAST_JSON = JSON.stringify(RAW, null, 2);
  $("#btnDownload").href = "data:application/json;charset=utf-8," + encodeURIComponent(LAST_JSON);

  // 4) Render
  renderAll(rows, regimeObj);
}

$("#btnRefresh").addEventListener("click", runOnce);
$("#filterType, #minConf, #searchBox, #sortBy, #sortDir").forEach
  ? $("#filterType, #minConf, #searchBox, #sortBy, #sortDir") // old browsers guard
  : null;
$("#filterType").addEventListener("change", ()=>applyFiltersAndRender(RAW));
$("#minConf").addEventListener("input", ()=>applyFiltersAndRender(RAW));
$("#searchBox").addEventListener("input", ()=>applyFiltersAndRender(RAW));
$("#sortBy").addEventListener("change", ()=>applyFiltersAndRender(RAW));
$("#sortDir").addEventListener("change", ()=>applyFiltersAndRender(RAW));
$("#btnCopy").addEventListener("click", ()=>{
  navigator.clipboard.writeText(LAST_JSON||"[]");
});

runOnce(); // initial load
</script>
</body>
</html>
